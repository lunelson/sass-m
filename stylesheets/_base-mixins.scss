//
// init mixins
// --------------------------------------------------------------------------

  @mixin init-fonts() {

    // if length of fonts is 0, merge fonts-default against it;
    $fonts: if(length($fonts) > 0, $fonts, $fonts-default) !global;

    // for each font in fonts, merge font against font-default
    @each $f, $font in $fonts {
      $font: map-merge($font-default, $font);
      $fonts: map-merge($fonts, ($f: $font)) !global;
    }
  }

  @mixin m-init($options: ()){

    // init fonts
    @include init-fonts();

    // parse out $options
    $options: map-merge($init-options-default, $options);
    $basis: map-get($options, 'basis');
    $output: map-get($options, 'output');

    // backup $base spec; merge spec against $medium-default
    $base-orig: $base !global;
    $base: __normalize-medium(map-merge($medium-default, $base)) !global;

    // if $media is empty, assign a default based on type; backup $media
    $media: if(length($media) > 0, $media, map-get($media-basis-defaults, $basis)) !global;
    $media-orig: $media !global;

    // create $current, as recursive merge target
    $current: $base;

    @each $m, $medium in $media {

      // setup $current by type, per $medium
      $current: call('__setup-medium-by-#{$basis}', $current, $medium);

      // merge $current back to $media
      $media: map-merge($media, ($m: $current)) !global;
    }

    @if $output {

      //
      // TODO
      //
      // => use sass-to-js function here
      // @include json-content(map-merge($globals, (media: $media, base: $base)));

      // output base styles, where needed
      // @include mm-for(size line) {
      //   html { font-size: __assert(m-value('scale'), em); }
      //   body { line-height: m-value('line'); }
      // }
      @include mm-for(size) { html { font-size: m-value('scale') * 1em; } }
      @include mm-for(line) { body { line-height: m-value('line'); } }

      //
      // TODO
      //
      // => make sure imported files have these mixins
      // @if map-get($options, 'init-outer') { @include init-outer(); }
      // @if map-get($options, 'init-wrap') { @include init-wrap(); }
      // @if map-get($options, 'init-grid') { @include init-grid(); }
      // @if map-get($options, 'init-stack') { @include init-stack(); }
      // @if map-get($options, 'init-typo') { @include init-typo(); }

    }
  }

//
// query mixins âœ…
// --------------------------------------------------------------------------


  @mixin m($min, $max: null) {
    $prev-m: $curr-m;
    $curr-m: $min !global;
    @media #{__query-string($min, $max)} { @content }
    $curr-m: $prev-m !global;
  }

  @mixin mm-at($keys: map-keys($media), $head: true, $tail: true) {
    $pair-set: __range-pairs($keys, $head, $tail);
    @if length($pair-set) == 0 { @content; }
    @else {
      @each $pair in $pair-set {
        @include m($pair...) {
          @content;
        }
      }
    }
  }

  @mixin mm-for($props...) {
    @include mm-at(__media-for($props...)) {
      @content;
    }
  }

  @mixin mm($lo: map-keys($media), $hi: null) {
    @if type-of($lo) == 'list' { @include mm-at($lo) { @content; } }
    @else {
      $media-keys: map-keys($media);
      $media-length: length($media-keys);
      $start: if($lo, (index($media-keys, $lo) or 1), 1);
      $end: if($hi, (index($media-keys, $hi) or $media-length), $media-length);
      $range: slice($media-keys, $start, $end);
      $head: ($lo or nth($media-keys, $start)) == __first($media-keys);
      $tail: ($hi or nth($media-keys, $end)) == __last($media-keys);
      @include mm-at($range, $head, $tail) { @content; }
    }
  }
